<?xml version="1.0" encoding="UTF-8"?>
<section name="Workbench">
	<item key="hasShownOverlayPopupBefore" value="true"/>
	<item key="replaceBarOpen" value="false"/>
	<list key="searchhistory">
		<item value="write"/>
	</list>
	<section name="org.eclipse.ui.texteditor.FindReplaceDialog">
		<item key="selection" value="&#x0A;&#x0A;///**&#x0A;// ******************************************************************************&#x0A;// * @file      syscalls.c&#x0A;// * @author    Auto-generated by STM32CubeIDE&#x0A;// * @brief     STM32CubeIDE Minimal System calls file&#x0A;// *&#x0A;// *            For more information about which c-functions&#x0A;// *            need which of these lowlevel functions&#x0A;// *            please consult the Newlib libc-manual&#x0A;// ******************************************************************************&#x0A;// * @attention&#x0A;// *&#x0A;// * Copyright (c) 2020-2025 STMicroelectronics.&#x0A;// * All rights reserved.&#x0A;// *&#x0A;// * This software is licensed under terms that can be found in the LICENSE file&#x0A;// * in the root directory of this software component.&#x0A;// * If no LICENSE file comes with this software, it is provided AS-IS.&#x0A;// *&#x0A;// ******************************************************************************&#x0A;// */&#x0A;//&#x0A;///* Includes */&#x0A;//#include &lt;sys/stat.h&gt;&#x0A;//#include &lt;stdlib.h&gt;&#x0A;//#include &lt;errno.h&gt;&#x0A;//#include &lt;stdio.h&gt;&#x0A;//#include &lt;signal.h&gt;&#x0A;//#include &lt;time.h&gt;&#x0A;//#include &lt;sys/time.h&gt;&#x0A;//#include &lt;sys/times.h&gt;&#x0A;//&#x0A;//&#x0A;///////////////////////////////////////////////////////////////////////////////////////////////////////////&#x0A;////&#x09;&#x09;&#x09;&#x09;&#x09;Implementation of printf like feature using ARM Cortex M3/M4/ ITM functionality&#x0A;////&#x09;&#x09;&#x09;&#x09;&#x09;This function will not work for ARM Cortex M0/M0+&#x0A;////&#x09;&#x09;&#x09;&#x09;&#x09;If you are using Cortex M0, then you can use semihosting feature of openOCD&#x0A;///////////////////////////////////////////////////////////////////////////////////////////////////////////&#x0A;//&#x0A;//&#x0A;////Debug Exception and Monitor Control Register base address&#x0A;//#define DEMCR        &#x09;&#x09;&#x09;*((volatile uint32_t*) 0xE000EDFCU )&#x0A;//&#x0A;///* ITM register addresses */&#x0A;//#define ITM_STIMULUS_PORT0   &#x09;*((volatile uint32_t*) 0xE0000000 )&#x0A;//#define ITM_TRACE_EN          &#x09;*((volatile uint32_t*) 0xE0000E00 )&#x0A;//&#x0A;//void ITM_SendChar(uint8_t ch)&#x0A;//{&#x0A;//&#x0A;//&#x09;//Enable TRCENA&#x0A;//&#x09;DEMCR |= ( 1 &lt;&lt; 24);&#x0A;//&#x0A;//&#x09;//enable stimulus port 0&#x0A;//&#x09;ITM_TRACE_EN |= ( 1 &lt;&lt; 0);&#x0A;//&#x0A;//&#x09;// read FIFO status in bit [0]:&#x0A;//&#x09;while(!(ITM_STIMULUS_PORT0 &amp; 1));&#x0A;//&#x0A;//&#x09;//Write to ITM stimulus port0&#x0A;//&#x09;ITM_STIMULUS_PORT0 = ch;&#x0A;//}&#x0A;//&#x0A;//&#x0A;///* Variables */&#x0A;//extern int __io_putchar(int ch) __attribute__((weak));&#x0A;//extern int __io_getchar(void) __attribute__((weak));&#x0A;//&#x0A;//&#x0A;//char *__env[1] = { 0 };&#x0A;//char **environ = __env;&#x0A;//&#x0A;//&#x0A;///* Functions */&#x0A;//void initialise_monitor_handles()&#x0A;//{&#x0A;//}&#x0A;//&#x0A;//int _getpid(void)&#x0A;//{&#x0A;//  return 1;&#x0A;//}&#x0A;//&#x0A;//int _kill(int pid, int sig)&#x0A;//{&#x0A;//  (void)pid;&#x0A;//  (void)sig;&#x0A;//  errno = EINVAL;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//void _exit (int status)&#x0A;//{&#x0A;//  _kill(status, -1);&#x0A;//  while (1) {}    /* Make sure we hang here */&#x0A;//}&#x0A;//&#x0A;//__attribute__((weak)) int _read(int file, char *ptr, int len)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  int DataIdx;&#x0A;//&#x0A;//  for (DataIdx = 0; DataIdx &lt; len; DataIdx++)&#x0A;//  {&#x0A;//    *ptr++ = __io_getchar();&#x0A;//  }&#x0A;//&#x0A;//  return len;&#x0A;//}&#x0A;//&#x0A;//__attribute__((weak)) int _write(int file, char *ptr, int len)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  int DataIdx;&#x0A;//&#x0A;//  for (DataIdx = 0; DataIdx &lt; len; DataIdx++)&#x0A;//  {&#x0A;//    //__io_putchar(*ptr++);&#x0A;//&#x09;  ITM_SendChar(*ptr++);&#x0A;//  }&#x0A;//  return len;&#x0A;//}&#x0A;//&#x0A;//int _close(int file)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//&#x0A;//int _fstat(int file, struct stat *st)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  st-&gt;st_mode = S_IFCHR;&#x0A;//  return 0;&#x0A;//}&#x0A;//&#x0A;//int _isatty(int file)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  return 1;&#x0A;//}&#x0A;//&#x0A;//int _lseek(int file, int ptr, int dir)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  (void)ptr;&#x0A;//  (void)dir;&#x0A;//  return 0;&#x0A;//}&#x0A;//&#x0A;//int _open(char *path, int flags, ...)&#x0A;//{&#x0A;//  (void)path;&#x0A;//  (void)flags;&#x0A;//  /* Pretend like we always fail */&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//int _wait(int *status)&#x0A;//{&#x0A;//  (void)status;&#x0A;//  errno = ECHILD;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//int _unlink(char *name)&#x0A;//{&#x0A;//  (void)name;&#x0A;//  errno = ENOENT;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//int _times(struct tms *buf)&#x0A;//{&#x0A;//  (void)buf;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//int _stat(char *file, struct stat *st)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  st-&gt;st_mode = S_IFCHR;&#x0A;//  return 0;&#x0A;//}&#x0A;//&#x0A;//int _link(char *old, char *new)&#x0A;//{&#x0A;//  (void)old;&#x0A;//  (void)new;&#x0A;//  errno = EMLINK;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//int _fork(void)&#x0A;//{&#x0A;//  errno = EAGAIN;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//int _execve(char *name, char **argv, char **env)&#x0A;//{&#x0A;//  (void)name;&#x0A;//  (void)argv;&#x0A;//  (void)env;&#x0A;//  errno = ENOMEM;&#x0A;//  return -1;&#x0A;//}&#x0A;"/>
		<list key="findhistory">
			<item value="&#x0A;&#x0A;///**&#x0A;// ******************************************************************************&#x0A;// * @file      syscalls.c&#x0A;// * @author    Auto-generated by STM32CubeIDE&#x0A;// * @brief     STM32CubeIDE Minimal System calls file&#x0A;// *&#x0A;// *            For more information about which c-functions&#x0A;// *            need which of these lowlevel functions&#x0A;// *            please consult the Newlib libc-manual&#x0A;// ******************************************************************************&#x0A;// * @attention&#x0A;// *&#x0A;// * Copyright (c) 2020-2025 STMicroelectronics.&#x0A;// * All rights reserved.&#x0A;// *&#x0A;// * This software is licensed under terms that can be found in the LICENSE file&#x0A;// * in the root directory of this software component.&#x0A;// * If no LICENSE file comes with this software, it is provided AS-IS.&#x0A;// *&#x0A;// ******************************************************************************&#x0A;// */&#x0A;//&#x0A;///* Includes */&#x0A;//#include &lt;sys/stat.h&gt;&#x0A;//#include &lt;stdlib.h&gt;&#x0A;//#include &lt;errno.h&gt;&#x0A;//#include &lt;stdio.h&gt;&#x0A;//#include &lt;signal.h&gt;&#x0A;//#include &lt;time.h&gt;&#x0A;//#include &lt;sys/time.h&gt;&#x0A;//#include &lt;sys/times.h&gt;&#x0A;//&#x0A;//&#x0A;///////////////////////////////////////////////////////////////////////////////////////////////////////////&#x0A;////&#x09;&#x09;&#x09;&#x09;&#x09;Implementation of printf like feature using ARM Cortex M3/M4/ ITM functionality&#x0A;////&#x09;&#x09;&#x09;&#x09;&#x09;This function will not work for ARM Cortex M0/M0+&#x0A;////&#x09;&#x09;&#x09;&#x09;&#x09;If you are using Cortex M0, then you can use semihosting feature of openOCD&#x0A;///////////////////////////////////////////////////////////////////////////////////////////////////////////&#x0A;//&#x0A;//&#x0A;////Debug Exception and Monitor Control Register base address&#x0A;//#define DEMCR        &#x09;&#x09;&#x09;*((volatile uint32_t*) 0xE000EDFCU )&#x0A;//&#x0A;///* ITM register addresses */&#x0A;//#define ITM_STIMULUS_PORT0   &#x09;*((volatile uint32_t*) 0xE0000000 )&#x0A;//#define ITM_TRACE_EN          &#x09;*((volatile uint32_t*) 0xE0000E00 )&#x0A;//&#x0A;//void ITM_SendChar(uint8_t ch)&#x0A;//{&#x0A;//&#x0A;//&#x09;//Enable TRCENA&#x0A;//&#x09;DEMCR |= ( 1 &lt;&lt; 24);&#x0A;//&#x0A;//&#x09;//enable stimulus port 0&#x0A;//&#x09;ITM_TRACE_EN |= ( 1 &lt;&lt; 0);&#x0A;//&#x0A;//&#x09;// read FIFO status in bit [0]:&#x0A;//&#x09;while(!(ITM_STIMULUS_PORT0 &amp; 1));&#x0A;//&#x0A;//&#x09;//Write to ITM stimulus port0&#x0A;//&#x09;ITM_STIMULUS_PORT0 = ch;&#x0A;//}&#x0A;//&#x0A;//&#x0A;///* Variables */&#x0A;//extern int __io_putchar(int ch) __attribute__((weak));&#x0A;//extern int __io_getchar(void) __attribute__((weak));&#x0A;//&#x0A;//&#x0A;//char *__env[1] = { 0 };&#x0A;//char **environ = __env;&#x0A;//&#x0A;//&#x0A;///* Functions */&#x0A;//void initialise_monitor_handles()&#x0A;//{&#x0A;//}&#x0A;//&#x0A;//int _getpid(void)&#x0A;//{&#x0A;//  return 1;&#x0A;//}&#x0A;//&#x0A;//int _kill(int pid, int sig)&#x0A;//{&#x0A;//  (void)pid;&#x0A;//  (void)sig;&#x0A;//  errno = EINVAL;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//void _exit (int status)&#x0A;//{&#x0A;//  _kill(status, -1);&#x0A;//  while (1) {}    /* Make sure we hang here */&#x0A;//}&#x0A;//&#x0A;//__attribute__((weak)) int _read(int file, char *ptr, int len)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  int DataIdx;&#x0A;//&#x0A;//  for (DataIdx = 0; DataIdx &lt; len; DataIdx++)&#x0A;//  {&#x0A;//    *ptr++ = __io_getchar();&#x0A;//  }&#x0A;//&#x0A;//  return len;&#x0A;//}&#x0A;//&#x0A;//__attribute__((weak)) int _write(int file, char *ptr, int len)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  int DataIdx;&#x0A;//&#x0A;//  for (DataIdx = 0; DataIdx &lt; len; DataIdx++)&#x0A;//  {&#x0A;//    //__io_putchar(*ptr++);&#x0A;//&#x09;  ITM_SendChar(*ptr++);&#x0A;//  }&#x0A;//  return len;&#x0A;//}&#x0A;//&#x0A;//int _close(int file)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//&#x0A;//int _fstat(int file, struct stat *st)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  st-&gt;st_mode = S_IFCHR;&#x0A;//  return 0;&#x0A;//}&#x0A;//&#x0A;//int _isatty(int file)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  return 1;&#x0A;//}&#x0A;//&#x0A;//int _lseek(int file, int ptr, int dir)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  (void)ptr;&#x0A;//  (void)dir;&#x0A;//  return 0;&#x0A;//}&#x0A;//&#x0A;//int _open(char *path, int flags, ...)&#x0A;//{&#x0A;//  (void)path;&#x0A;//  (void)flags;&#x0A;//  /* Pretend like we always fail */&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//int _wait(int *status)&#x0A;//{&#x0A;//  (void)status;&#x0A;//  errno = ECHILD;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//int _unlink(char *name)&#x0A;//{&#x0A;//  (void)name;&#x0A;//  errno = ENOENT;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//int _times(struct tms *buf)&#x0A;//{&#x0A;//  (void)buf;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//int _stat(char *file, struct stat *st)&#x0A;//{&#x0A;//  (void)file;&#x0A;//  st-&gt;st_mode = S_IFCHR;&#x0A;//  return 0;&#x0A;//}&#x0A;//&#x0A;//int _link(char *old, char *new)&#x0A;//{&#x0A;//  (void)old;&#x0A;//  (void)new;&#x0A;//  errno = EMLINK;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//int _fork(void)&#x0A;//{&#x0A;//  errno = EAGAIN;&#x0A;//  return -1;&#x0A;//}&#x0A;//&#x0A;//int _execve(char *name, char **argv, char **env)&#x0A;//{&#x0A;//  (void)name;&#x0A;//  (void)argv;&#x0A;//  (void)env;&#x0A;//  errno = ENOMEM;&#x0A;//  return -1;&#x0A;//}&#x0A;"/>
		</list>
	</section>
</section>
